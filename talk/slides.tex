% Created 2022-05-25 Wed 12:18
% Intended LaTeX compiler: pdflatex
\documentclass[t,10pt,xcolor={dvipsnames}]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\AtBeginSection[]{\begin{frame}<beamer>\frametitle{}\tableofcontents[currentsection]\end{frame}}
\definecolor{Orange}{rgb}{1,0.5,0}
\usepackage{listings}
\usetheme{Madrid}
\author{Mark Tullsen, William Harris, Peter Wyatt}
\date{\today}
\title{Strengthening Weak Links in the PDF Trust Chain}
\hypersetup{
 pdfauthor={Mark Tullsen, William Harris, Peter Wyatt},
 pdftitle={Strengthening Weak Links in the PDF Trust Chain},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Pre-DOM: "What Lies Beneath" is a Concern}
\label{sec:orgcb4f31c}
\begin{frame}[label={sec:org183eb0c}]{PDF Complexity?}
\begin{center}
 { \hspace{5pt}
   \includegraphics[width=0.4\linewidth]{../figures/pdf-structure.png}
 } \hspace{30pt}
 \raisebox{-1\baselineskip}
          {\includegraphics[width=0.30\linewidth]{../figures/pdf-structure-incremental.png}}
\end{center}
\end{frame}

\begin{frame}[label={sec:org0144db3}]{PDF Trust Chain}
\begin{center}
\includegraphics[width=0.47\linewidth]{../figures/Stages.png}
\end{center}
\end{frame}

\begin{frame}[label={sec:org728a087}]{Vulnerabilities Occurring Primarily Pre-DOM}
\begin{itemize}
\item Schizophrenic files (different tools, different renderings)
\item Polyglot files (file being in 2+ formats)
\item Shadow attacks
\begin{itemize}
\item i.e., attacker can add "shadow content" that is PDF-signed, then reveal
at will without giving clear warnings to user.
\item possible because of ability to sign \emph{dead objects} and \emph{cavities}
\end{itemize}
\item Multiple places for hidden/unused/malicious data in PDF
\begin{itemize}
\item non-obvious places, unnoticed when "simply parsing"
\item e.g., shadow-attacks
\item dead bytes, dead objects, dead updates, dead linearization sections, etc.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgaae2d4e}]{PDF, and Pre-DOM, Challenges}
\begin{itemize}
\item Lack of formality in standard. Thus, implementations:
\begin{itemize}
\item are more effort
\item over implement, under implement, wrongly implement
\end{itemize}
\item No definition of acceptable, reasonable error recovery
\item Less than ideal design that reflects 27 years of an evolving standard
\item Pre-DOM processing
\begin{itemize}
\item is where many parsing errors \& recovery occur
\item is non-trivial
\item involves multiple interdependent features
\item involves multiple redundant features
\begin{itemize}
\item schizophrenic if these features aren't mutually consistent
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\section{Modeling Pre-DOM: Highlights}
\label{sec:org99f1197}
\begin{frame}[label={sec:org173bc68},fragile]{Stage 4: Transform XRef Map to Object Map}
 \begin{center}
\includegraphics[width=0.8\linewidth]{images/diagram1/cropped-diagram1.001.png}
\end{center}
\begin{verbatim}
      ...
100   3 0 obj 99 endobj
123   % object 4 is not here
151   5 0 obj
      <<
      /Type /ObjStm
      /Length 3 0 R   % indirect!
      /N 2            % 2 objects; (potentially indirect)
      /First 10       % offset to 1st object (potentially indirect)
      >>
      stream
      4 0 6 100
      V1 % PDF-Value here, 4 0 R, [fake comment] 
      V2 % PDF-Value here, 6 0 R, [fake comment]
      endstream
      endobj
409   7 0 obj ... endobj
      ...
\end{verbatim}
\end{frame}

\begin{frame}[label={sec:org5d5419a}]{Parser NEQ Validator}
Validator: only valid PDFs can produce DOM (must Fail otherwise)

\vspace{10pt}
\includegraphics[width=0.90\linewidth]{images/pNEQv-1.png}
\end{frame}

\begin{frame}[label={sec:orgbbff79f}]{Parser NEQ Validator}
Parser: efficiently, construct the correct DOM when a valid PDF
\vspace{10pt}
\includegraphics[width=0.90\linewidth]{images/pNEQv-2.png}
\end{frame}

\begin{frame}[label={sec:org44c92a9}]{Parser NEQ Validator}
\vspace{20pt}
\includegraphics[width=0.90\linewidth]{images/pNEQv-3.png}
\end{frame}

\begin{frame}[label={sec:org9b54fc5},fragile]{Turning Parser into Validator}
 Parser specification is designed to be
\begin{itemize}
\item understandable: clear, pure Haskell
\item phased, clearly terminating (get parallelizability for free)
\item very lazy "Parser" (big input cloud)
\end{itemize}

We can extend spec into a validator, orthogonally, via “validate” constructs
(turning on/off on with command-line flag).  E.g.,
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
do
  (xrefRaw, xrefEndOff) <- pXrefRaw
  validate $
     verifyXrefRaw xrefRaw -- ensures no duplicates
\end{lstlisting}
\end{frame}

\section{Conclusion}
\label{sec:orgc84a54b}
\begin{frame}[label={sec:org9238346}]{Accomplishments}
\begin{itemize}
\item A specification for pre-DOM parsing/computation
\begin{itemize}
\item Clarifies some subtle issues in PDF Standard
\item A growing list of PDF Association “issues” that we have contributed to
creating [23,24,\ldots{},30]
\end{itemize}
\item Have a unique tool for displaying updates \& cavities
\item A semantics that \ldots{} [FIXME]
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org01e5006}]{Future [FIXME: TOO MUCH]}
\begin{itemize}
\item Expand spec (uninteresting parts are unimplemented)
\item Turn spec into reference implementation (of pre-DOM)
\begin{itemize}
\item integrate with primitive parsers (implemented of course with Daedalus)
\item Thus, can test other tools’ conformance with our reference implementation
\end{itemize}
\item Extend specification
\begin{itemize}
\item support more PDF features (hybrids, compression, …)
\item add support for commonly allowed “exuberances”
\item add more “validate”s to get closer to a Validator
\end{itemize}
\item Our "pre-DOM inspection/validation tool"
\begin{itemize}
\item update semantics (as learned from writing spec)
\item further extensions
\end{itemize}
\end{itemize}
\end{frame}

\section{Preview: A Next Step}
\label{sec:orgeb95292}
\begin{frame}[label={sec:org2fcd0ee},fragile]{Implementation?}
 Tools \& renderers rarely need (\emph{demand}) the whole PDF
\begin{itemize}
\item reading?
\item parsing??
\item semantic checks???
\end{itemize}
\vspace{12pt}

Thus, this
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
parsePDF :: FileData -> Maybe PDFAbstractSyntax
\end{lstlisting}
is not going to be used in practice!     
\end{frame}

\begin{frame}[label={sec:org8794b6f},fragile]{One Solution \ldots{}}
 \begin{itemize}
\item For complex formats,
\begin{itemize}
\item tools are "projections": rarely to parse/validate all.
\item may have alternate "parsing paths" we want to take
\end{itemize}

\item Shotgun Parsers?
\begin{itemize}
\item \ldots{} the deadliest of patterns: "Input data checking, handling interspersed
with processing logic"
\end{itemize}
\item I.e., we provide multiple parsers where the following is interspersed through
code and the relation between these is \alert{not specified}:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
parseA :: Offset -> IO A
parseB :: Offset -> IO B
parseC :: Offset -> IO C
validateA :: A -> IO ()
validateB :: A -> B -> IO ()
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org2de9633},fragile]{Better Solution, Parser as API}
 We provide four interdependent calls (not \emph{entry points}):
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
parseHdrTrlr :: FileData -> IO HdrTrlr
parseUpdates :: HdrTrlr -> IO [Updates]
createXRef   :: [Updates] -> IO XRef
derefObjId   :: ObjId -> XRef -> IO PdfValue
\end{lstlisting}
(Types can be as abstract as we wish.)

\vspace{18pt}
Using this, we write abstractions on the above:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
getInitialUpdate :: FileData -> IO XRef
getRootValue     :: HdrTrailer -> XRef -> PdfValue
getPageTree      :: XRef -> Tree PdfValue
\end{lstlisting}
\end{frame}
\end{document}
